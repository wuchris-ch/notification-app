import os
import json
import re
from datetime import datetime, time
from typing import Dict, Any, Optional, Tuple
from openai import OpenAI
from croniter import croniter
import pytz
import logging

# Set up logging
logger = logging.getLogger(__name__)

# Initialize OpenRouter client with error handling
def get_openrouter_client():
    """Get OpenRouter client with proper error handling"""
    from .config import settings
    
    api_key = settings.OPENROUTER_API_KEY or os.getenv("OPENROUTER_API_KEY")
    if not api_key:
        raise ValueError("OPENROUTER_API_KEY is not configured. Please set it in your environment variables.")
    
    return OpenAI(
        base_url="https://openrouter.ai/api/v1",
        api_key=api_key,
    )

def parse_natural_language_reminder(text: str, user_timezone: str = "America/Vancouver") -> Dict[str, Any]:
    """
    Parse natural language text into structured reminder data using AI.
    
    Args:
        text: Natural language description of the reminder
        user_timezone: User's timezone for scheduling
        
    Returns:
        Dictionary with parsed reminder data including title, body, cron, and metadata
    """
    
    # Get current time in user's timezone for context
    tz = pytz.timezone(user_timezone)
    current_time = datetime.now(tz)
    current_time_str = current_time.strftime("%Y-%m-%d %H:%M %Z")
    
    system_prompt = f"""You are an AI assistant that converts natural language into structured reminder data for a family notification system.

Current time: {current_time_str}
User timezone: {user_timezone}

Your task is to parse the user's natural language input and return a JSON object with the following structure:
{{
    "title": "Brief, clear title for the reminder (max 120 chars)",
    "body": "Optional detailed message (can be null if not needed)",
    "cron": "Valid cron expression (5 fields: minute hour day month dow)",
    "schedule_description": "Human-readable description of when it runs",
    "confidence": "high|medium|low - your confidence in the parsing"
}}

Cron format: minute hour day month day-of-week
- minute: 0-59
- hour: 0-23 (24-hour format)
- day: 1-31
- month: 1-12
- day-of-week: 0-6 (0=Sunday, 1=Monday, etc.)

Examples:
- "0 8 * * *" = Daily at 8:00 AM
- "30 7 * * 1-5" = Weekdays at 7:30 AM
- "0 18 * * 0" = Sundays at 6:00 PM
- "0 9 1 * *" = First day of every month at 9:00 AM
- "0 12 25 12 *" = December 25th at noon

Common patterns to recognize:
- "every day/daily" → "* * *"
- "weekdays" → "1-5" (Monday-Friday)
- "weekends" → "0,6" (Sunday,Saturday)
- "every Monday" → "1"
- "every week" → same day of week
- "every month" → same day of month
- "every year" → same day and month

Time parsing:
- "8am", "8:00am", "8 in the morning" → hour=8
- "6pm", "6:00pm", "6 in the evening" → hour=18
- "noon", "12pm" → hour=12
- "midnight", "12am" → hour=0

If time is not specified, use reasonable defaults:
- Morning reminders: 8:00 AM
- Medication: 8:00 AM, 12:00 PM, 6:00 PM (depending on context)
- Evening reminders: 6:00 PM
- Bedtime reminders: 9:00 PM

Be smart about context:
- "take medication" → likely daily
- "doctor appointment" → likely one-time or specific date
- "exercise" → likely daily or specific days
- "call mom" → likely weekly
- "pay bills" → likely monthly

Return only valid JSON. If you cannot parse the input confidently, set confidence to "low" and make reasonable assumptions."""

    user_prompt = f"Parse this reminder request: {text}"
    
    try:
        # Get client with error handling
        client = get_openrouter_client()
        
        logger.info(f"Parsing natural language: {text[:50]}...")
        
        response = client.chat.completions.create(
            model="x-ai/grok-4-fast:free",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1,
            max_tokens=500
        )
        
        # Extract JSON from response
        content = response.choices[0].message.content.strip()
        logger.debug(f"AI response: {content}")
        
        # Try to extract JSON if it's wrapped in markdown or other text
        json_match = re.search(r'\{.*\}', content, re.DOTALL)
        if json_match:
            content = json_match.group()
        
        parsed_data = json.loads(content)
        
        # Validate the cron expression
        try:
            croniter(parsed_data["cron"])
        except (ValueError, KeyError) as e:
            logger.error(f"Invalid cron expression: {parsed_data.get('cron', 'None')} - {e}")
            raise ValueError("Invalid cron expression generated by AI")
        
        # Ensure required fields
        if not parsed_data.get("title"):
            logger.error("AI did not generate a title")
            raise ValueError("No title generated by AI")
        
        # Truncate title if too long
        if len(parsed_data["title"]) > 120:
            parsed_data["title"] = parsed_data["title"][:117] + "..."
        
        logger.info(f"Successfully parsed: {parsed_data['title']} - {parsed_data['cron']}")
        return parsed_data
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON parsing error: {e}")
        raise ValueError(f"AI returned invalid JSON format: {e}")
    except Exception as e:
        logger.error(f"AI parsing error: {e}")
        if "api_key" in str(e).lower():
            raise ValueError("OpenRouter API key is invalid or missing")
        elif "rate limit" in str(e).lower():
            raise ValueError("Rate limit exceeded. Please try again in a moment")
        elif "network" in str(e).lower() or "connection" in str(e).lower():
            raise ValueError("Network error connecting to AI service. Please check your internet connection")
        else:
            raise ValueError(f"AI service error: {e}")


def validate_and_enhance_reminder(parsed_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate and enhance the parsed reminder data.
    
    Args:
        parsed_data: Dictionary from parse_natural_language_reminder
        
    Returns:
        Enhanced and validated reminder data
    """
    
    # Validate cron expression
    try:
        cron_iter = croniter(parsed_data["cron"])
        # Get next execution time to verify it's valid
        next_run = cron_iter.get_next(datetime)
        parsed_data["next_execution"] = next_run.isoformat()
    except Exception as e:
        raise ValueError(f"Invalid cron expression: {e}")
    
    # Ensure title is not empty and within limits
    title = parsed_data.get("title", "").strip()
    if not title:
        raise ValueError("Title cannot be empty")
    if len(title) > 120:
        title = title[:117] + "..."
        parsed_data["title"] = title
    
    # Clean up body
    body = parsed_data.get("body")
    if body:
        body = body.strip()
        if not body or body.lower() in ["none", "null", "n/a"]:
            body = None
        parsed_data["body"] = body
    
    # Ensure confidence is valid
    confidence = parsed_data.get("confidence", "medium")
    if confidence not in ["high", "medium", "low"]:
        parsed_data["confidence"] = "medium"
    
    return parsed_data


def generate_cron_description(cron: str) -> str:
    """
    Generate a human-readable description of a cron expression.
    
    Args:
        cron: Cron expression string
        
    Returns:
        Human-readable description
    """
    try:
        parts = cron.split()
        if len(parts) != 5:
            return cron
        
        minute, hour, day, month, dow = parts
        
        # Time part
        if hour == "*":
            time_desc = "every hour"
        else:
            hour_int = int(hour)
            minute_int = int(minute) if minute != "*" else 0
            time_obj = time(hour_int, minute_int)
            time_desc = f"at {time_obj.strftime('%I:%M %p').lower()}"
        
        # Frequency part
        if day == "*" and month == "*" and dow == "*":
            freq_desc = "every day"
        elif day == "*" and month == "*" and dow == "1-5":
            freq_desc = "on weekdays"
        elif day == "*" and month == "*" and dow == "0,6":
            freq_desc = "on weekends"
        elif day == "*" and month == "*" and dow.isdigit():
            days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            freq_desc = f"every {days[int(dow)]}"
        elif day != "*" and month == "*":
            freq_desc = f"on the {day}{'st' if day.endswith('1') else 'nd' if day.endswith('2') else 'rd' if day.endswith('3') else 'th'} of every month"
        elif day != "*" and month != "*":
            months = ["", "January", "February", "March", "April", "May", "June",
                     "July", "August", "September", "October", "November", "December"]
            freq_desc = f"on {months[int(month)]} {day}"
        else:
            freq_desc = "on a custom schedule"
        
        return f"{freq_desc} {time_desc}".strip()
        
    except Exception:
        return cron